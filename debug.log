ls -lR
.:
total 54
drwxr-xr-x 1 o.midiyanto 1049089     0 Aug 14 21:36 api/
drwxr-xr-x 1 o.midiyanto 1049089     0 Sep 22 16:57 client/
-rw-r--r-- 1 o.midiyanto 1049089     7 Sep 22 17:04 debug.log
-rw-r--r-- 1 o.midiyanto 1049089   597 Aug 19 17:40 docker-compose.yaml
-rw-r--r-- 1 o.midiyanto 1049089   315 Aug 17 16:25 Dockerfile
-rwxr-xr-x 1 o.midiyanto 1049089   284 Aug 19 17:08 docker-rebuild.sh*
-rw-r--r-- 1 o.midiyanto 1049089  2226 Sep 22 16:56 go.mod
-rw-r--r-- 1 o.midiyanto 1049089 12091 Sep 22 16:56 go.sum
-rw-r--r-- 1 o.midiyanto 1049089  9122 Aug 19 16:18 main.go
drwxr-xr-x 1 o.midiyanto 1049089     0 Aug 13 17:23 parser/
-rw-r--r-- 1 o.midiyanto 1049089  6288 Aug 19 11:31 test.py
drwxr-xr-x 1 o.midiyanto 1049089     0 Aug 14 23:28 web/

./api:
total 12
-rw-r--r-- 1 o.midiyanto 1049089 1496 Aug 14 21:40 auth-token.go
-rw-r--r-- 1 o.midiyanto 1049089 7390 Aug 15 00:18 delete-computer.go

./client:
total 24
-rw-r--r-- 1 o.midiyanto 1049089 8525 Sep 22 16:59 ad-auth.go
-rw-r--r-- 1 o.midiyanto 1049089 1175 Aug 13 17:29 elasticsearch-auth.go
-rw-r--r-- 1 o.midiyanto 1049089 2195 Sep 22 16:57 ocs-auth-session.go
-rw-r--r-- 1 o.midiyanto 1049089 1306 Aug 13 15:48 ocs-mysql-auth.go

./parser:
total 16
-rw-r--r-- 1 o.midiyanto 1049089 3582 Sep 22 16:57 ad-list-computers.go
-rw-r--r-- 1 o.midiyanto 1049089 8019 Aug 18 18:35 elasticsearch-combine-list-computers.go
-rw-r--r-- 1 o.midiyanto 1049089 1370 Aug 13 16:42 ocs-list-computers.go

./web:
total 212
-rw-r--r-- 1 o.midiyanto 1049089 215137 Aug 15 08:35 frontend.go
cat api/auth-token.go
package api

import (
	"net/http"
	"ocs-ad-inventorymanagement/client"
	"os"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte(getJWTSecret())

func getJWTSecret() string {
	s := os.Getenv("JWT_SECRET")
	if s == "" {
		s = "supersecretjwtkey"
	}
	return s
}

type AuthTokenRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type AuthTokenResponse struct {
	Token string `json:"token"`
}

// POST /auth-token
func AuthTokenHandler(c *gin.Context) {
	var req AuthTokenRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}
	if req.Username == "" || req.Password == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "username dan password wajib diisi"})
		return
	}
	ocsCfg := client.LoadOCSAuthConfig()
	if err := client.AuthenticateOCSWeb(ocsCfg.OCSURL, req.Username, req.Password); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}
	// Success, generate JWT
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"username": req.Username,
		"exp":      time.Now().Add(3 * time.Minute).Unix(),
	})
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "gagal generate token"})
		return
	}
	c.JSON(http.StatusOK, AuthTokenResponse{Token: tokenString})
}
cat api/delete-computer.go
package api

import (
	"fmt"
	"net/http"
	"os"
	"regexp"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"gorm.io/gorm"
)

// DeleteComputerHandler handles GET /delete-computer?name=xxx
// Versi ini tetap menggunakan introspeksi skema namun dengan eksekusi query yang lebih aman.
// Serve frontend if not API call, else process API
// DeleteComputerHandler handles POST /delete-computer (API only, JSON input, JWT required)
func DeleteComputerHandler(db *gorm.DB) gin.HandlerFunc {
	// Regex untuk validasi nama tabel tetap dipertahankan sebagai lapisan pertahanan tambahan (defense-in-depth).
	var validTableName = regexp.MustCompile(`^[a-zA-Z0-9_]+$`)

	// Whitelist nama tabel yang diizinkan
	var allowedTables = map[string]struct{}{
		"accesslog": {}, "accountinfo": {}, "accountinfo_config": {}, "archive": {}, "assets_categories": {}, "auth_attempt": {}, "batteries": {}, "bios": {}, "blacklist_macaddresses": {}, "blacklist_serials": {}, "blacklist_subnet": {}, "config": {}, "config_ldap": {}, "conntrack": {}, "controllers": {}, "cpus": {}, "cve_search": {}, "cve_search_computer": {}, "cve_search_correspondance": {}, "cve_search_history": {}, "deleted_equiv": {}, "deploy": {}, "devices": {}, "devicetype": {}, "dico_ignored": {}, "dico_soft": {}, "download_affect_rules": {}, "download_available": {}, "download_enable": {}, "download_history": {}, "download_servers": {}, "downloadwk_conf_values": {}, "downloadwk_fields": {}, "downloadwk_history": {}, "downloadwk_pack": {}, "downloadwk_statut_request": {}, "downloadwk_tab_values": {}, "drives": {}, "engine_mutex": {}, "engine_persistent": {}, "extensions": {}, "files": {}, "groups": {}, "groups_cache": {}, "hardware": {}, "hardware_osname_cache": {}, "history": {}, "inputs": {}, "itmgmt_comments": {}, "javainfo": {}, "journallog": {}, "languages": {}, "layouts": {}, "local_groups": {}, "local_users": {}, "locks": {}, "memories": {}, "modems": {}, "monitors": {}, "netmap": {}, "network_devices": {}, "networks": {}, "notification": {}, "notification_config": {}, "ports": {}, "printers": {}, "prolog_conntrack": {}, "regconfig": {}, "registry": {}, "registry_name_cache": {}, "registry_regvalue_cache": {}, "reports_notifications": {}, "repository": {}, "saas": {}, "saas_exp": {}, "save_query": {}, "schedule_wol": {}, "sim": {}, "slots": {}, "snmp_accountinfo": {}, "snmp_communities": {}, "snmp_configs": {}, "snmp_default": {}, "snmp_labels": {}, "snmp_mibs": {}, "snmp_ocs": {}, "snmp_types": {}, "snmp_types_conditions": {}, "software": {}, "software_categories": {}, "software_categories_link": {}, "software_category_exp": {}, "software_link": {}, "software_name": {}, "software_publisher": {}, "software_version": {}, "softwares_name_cache": {}, "sounds": {}, "ssl_store": {}, "storages": {}, "subnet": {}, "tags": {}, "temp_files": {}, "usbdevices": {}, "videos": {}, "virtualmachines": {},
	}

	return func(c *gin.Context) {
		// --- JWT Auth ---
		authHeader := c.GetHeader("Authorization")
		if !strings.HasPrefix(authHeader, "Bearer ") {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header (Bearer <token>) wajib"})
			return
		}
		tokenString := strings.TrimPrefix(authHeader, "Bearer ")
		jwtSecret := os.Getenv("JWT_SECRET")
		if jwtSecret == "" {
			jwtSecret = "supersecretjwtkey"
		}
		token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method")
			}
			return []byte(jwtSecret), nil
		})
		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token tidak valid"})
			return
		}
		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token tidak valid"})
			return
		}
		username, _ := claims["username"].(string)
		if username == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token tidak valid (no username)"})
			return
		}
		// Parse JSON body
		var req struct {
			Name string `json:"name"`
		}
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON, harus ada field 'name'"})
			return
		}
		name := req.Name
		if name == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "parameter 'name' wajib diisi"})
			return
		}

		// Struct sementara untuk menampung hasil query ID
		var hardware struct {
			ID int
		}

		// Cari id hardware berdasarkan nama.
		if err := db.Table("hardware").Select("id").Where("name = ?", name).First(&hardware).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				c.JSON(http.StatusNotFound, gin.H{"error": "Computer Not Found"})
				return
			}
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Gagal mencari hardware: %v", err)})
			return
		}

		hwID := hardware.ID

		// Ambil daftar tabel yang punya kolom HARDWARE_ID di skema saat ini (logika ini dipertahankan sesuai permintaan).
		type tableRow struct {
			TableName string `gorm:"column:TABLE_NAME"`
		}
		var tables []tableRow
		query := `
			SELECT DISTINCT TABLE_NAME
			FROM information_schema.COLUMNS
			WHERE TABLE_SCHEMA = DATABASE() AND COLUMN_NAME = 'HARDWARE_ID'
		`
		if err := db.Raw(query).Scan(&tables).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Gagal mengambil daftar tabel: %v", err)})
			return
		}

		// Mulai transaksi
		tx := db.Begin()
		if tx.Error != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Gagal memulai transaksi: %v", tx.Error)})
			return
		}

		// Defer a rollback in case of panic
		defer func() {
			if r := recover(); r != nil {
				tx.Rollback()
			}
		}()

		for _, t := range tables {
			tableName := t.TableName

			// Lakukan validasi nama tabel sebagai lapisan keamanan tambahan.
			if !validTableName.MatchString(tableName) {
				// skip tabel yang namanya tidak valid untuk mencegah hal tak terduga.
				continue
			}
			// Validasi whitelist nama tabel
			if _, ok := allowedTables[tableName]; !ok {
				// skip tabel yang tidak ada di whitelist
				continue
			}

			// --- PERUBAHAN UTAMA ADA DI SINI ---
			// Ganti Sprintf dengan metode GORM yang aman untuk nama tabel dinamis.
			// GORM akan menangani quoting (misal: `nama_tabel`) secara otomatis dan aman.
			if err := tx.Table(tableName).Where("HARDWARE_ID = ?", hwID).Delete(nil).Error; err != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Gagal menghapus dari tabel %s: %v", tableName, err)})
				return
			}
		}

		// Hapus record hardware itu sendiri
		if err := tx.Table("hardware").Where("id = ?", hwID).Delete(nil).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Gagal menghapus hardware: %v", err)})
			return
		}

		// Commit transaksi
		if err := tx.Commit().Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Gagal commit transaksi: %v", err)})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"message":    fmt.Sprintf("Semua data yang terkait dengan computer ID %d telah berhasil dihapus.", hwID),
			"deleted_by": username,
		})

	}
}
cat client/ad-auth.go
// client/ad-auth.go
package client

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"strings"
	"sync"
	"time"
)

const admpCSRFCookieName = "admpcsrf"

// Config menyimpan semua konfigurasi yang dibutuhkan oleh client.
type Config struct {
	BaseURL           string
	Username          string
	EncryptedPassword string
	ReportID          string
	GenerationID      string
}

// Client adalah object yang akan menangani semua interaksi HTTP.
type Client struct {
	httpClient *http.Client
	config     Config
	mu         sync.RWMutex
}

// IsSessionValid checks if the ADManager Plus session is still valid by checking the existence of the CSRF cookie.
func (c *Client) IsSessionValid() bool {
	parsedBaseURL, err := url.Parse(c.config.BaseURL)
	if err != nil {
		return false
	}
	for _, cookie := range c.httpClient.Jar.Cookies(parsedBaseURL) {
		if cookie.Name == admpCSRFCookieName && cookie.Value != "" {
			return true
		}
	}
	return false
}

// GetLatestGenerationID posts to generateReport and returns the latest generationId for the given reportId and params.
func (c *Client) GetLatestGenerationID(reportId string, params string) (string, error) {
	genURL := c.config.BaseURL + "/api/json/reports/report/generateReport"
	parsedBaseURL, _ := url.Parse(c.config.BaseURL)
	var csrfToken string
	for _, cookie := range c.httpClient.Jar.Cookies(parsedBaseURL) {
		if cookie.Name == admpCSRFCookieName {
			csrfToken = cookie.Value
			break
		}
	}
	if csrfToken == "" {
		return "", fmt.Errorf("tidak dapat menemukan cookie '%s' setelah login", admpCSRFCookieName)
	}
	payload := url.Values{}
	payload.Set("reportId", reportId)
	payload.Set("params", params)
	payload.Set("admpcsrf", csrfToken)
	req, _ := http.NewRequest("POST", genURL, strings.NewReader(payload.Encode()))
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("gagal POST generateReport: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("gagal generateReport, status: %d, body: %s", resp.StatusCode, string(body))
	}
	body, _ := io.ReadAll(resp.Body)
	var genResp map[string]interface{}
	if err := json.Unmarshal(body, &genResp); err != nil {
		return "", fmt.Errorf("gagal parsing response generateReport: %v", err)
	}
	if genId, ok := genResp["generationId"].(float64); ok {
		return fmt.Sprintf("%d", int(genId)), nil
	}
	return "", fmt.Errorf("generationId tidak ditemukan di response")
}

// SetGenerationID menyimpan generationId terbaru secara thread-safe.
func (c *Client) SetGenerationID(id string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.config.GenerationID = id
}

// GetCachedGenerationID mengembalikan generationId yang tersimpan secara thread-safe.
func (c *Client) GetCachedGenerationID() string {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.config.GenerationID
}

// RefreshGenerationID mengambil generationId terbaru dan menyimpannya.
func (c *Client) RefreshGenerationID(reportId string, params string) error {
	id, err := c.GetLatestGenerationID(reportId, params)
	if err != nil {
		return err
	}
	c.SetGenerationID(id)
	log.Println("[INFO] AD Manager Plus - Refreshed Generation ID:", id)
	return nil
}

// New membuat instance baru dari Client.
func New(config Config) (*Client, error) {
	jar, err := cookiejar.New(nil)
	if err != nil {
		return nil, fmt.Errorf("gagal membuat cookie jar: %v", err)
	}
	return &Client{
		httpClient: &http.Client{Jar: jar},
		config:     config,
	}, nil
}

// Login adalah method dari Client yang melakukan autentikasi.
func (c *Client) Login() error {
	// Langkah 1: GET halaman login
	resp, err := c.httpClient.Get(c.config.BaseURL + "/")
	if err != nil {
		return fmt.Errorf("gagal melakukan GET request awal: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("status code tidak valid saat GET awal: %d", resp.StatusCode)
	}
	// log.Println("[INFO] ADManager Plus - Initial Cookie Successfully fetched.")

	// Langkah 2: POST data login
	loginURL := c.config.BaseURL + "/j_security_check?LogoutFromSSO=true"
	loginPayload := url.Values{}
	loginPayload.Set("is_admp_pass_encrypted", "true")
	loginPayload.Set("j_username", c.config.Username)
	loginPayload.Set("j_password", c.config.EncryptedPassword)
	loginPayload.Set("domainName", "ADManager Plus Authentication")
	loginPayload.Set("AUTHRULE_NAME", "ADAuthenticator")

	req, _ := http.NewRequest("POST", loginURL, strings.NewReader(loginPayload.Encode()))
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	resp, err = c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("gagal melakukan POST request login: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("login gagal dengan status code: %d", resp.StatusCode)
	}

	log.Println("[SUCCESS] AD Manager Plus - Login Success! Session is valid.")
	return nil
}

// FetchComputerReport mengambil data laporan menggunakan generationId yang tersimpan.
func (c *Client) FetchComputerReport() ([]byte, error) {
	// Hardcoded reportId untuk 'All Computers' (bisa diubah jika perlu)
	reportId := "210"
	// Params sesuai contoh, bisa diubah/dibuat dinamis jika perlu
	params := `{"selectedDomains":["satnusa.com"],"domainVsOUList":{"DC=satnusa,DC=com":[]},"domainVsExcludeOUList":{"DC=satnusa,DC=com":[]},"domainVsExcludeChildOU":{"DC=satnusa,DC=com":false}}`
	generationId := c.GetCachedGenerationID()
	if generationId == "" {
		id, err := c.GetLatestGenerationID(reportId, params)
		if err != nil {
			return nil, fmt.Errorf("gagal mendapatkan generationId: %v", err)
		}
		c.SetGenerationID(id)
		generationId = id
	}
	log.Println("[INFO] AD Manager Plus - Using Generation ID:", generationId)
	reportURL := c.config.BaseURL + "/api/json/reports/report/getReportResultRows"
	parsedBaseURL, _ := url.Parse(c.config.BaseURL)

	var csrfToken string
	for _, cookie := range c.httpClient.Jar.Cookies(parsedBaseURL) {
		if cookie.Name == admpCSRFCookieName {
			csrfToken = cookie.Value
			break
		}
	}
	if csrfToken == "" {
		return nil, fmt.Errorf("tidak dapat menemukan cookie '%s' setelah login", admpCSRFCookieName)
	}

	paramsData := map[string]interface{}{
		"pageNavigateData": map[string]interface{}{"startIndex": 1, "toIndex": 999999, "rangeList": []int{25, 50, 75, 100}, "range": 999999, "totalCount": 0, "isNavigate": false},
		"searchText":       map[string]interface{}{}, "searchCriteriaType": map[string]interface{}{}, "sortAttribId": -1,
		"sortingOrder": true, "reportResultFilter": map[string]interface{}{}, "rvcFilter": map[string]interface{}{}, "viewOf": "default",
		"dbFilterDetails": map[string]interface{}{"objectId": 3, "filters": []interface{}{}},
	}
	paramsJSON, err := json.Marshal(paramsData)
	if err != nil {
		return nil, fmt.Errorf("gagal membuat JSON untuk params: %v", err)
	}

	reportPayload := url.Values{}
	reportPayload.Set("reportId", reportId)
	reportPayload.Set("generationId", generationId)
	reportPayload.Set("params", string(paramsJSON))
	reportPayload.Set("intersect", "false")
	reportPayload.Set("admpcsrf", csrfToken)

	// Polling: try up to 10 times, 2 seconds apart, until valid JSON is returned
	var lastErr error
	for i := 0; i < 10; i++ {
		req, _ := http.NewRequest("POST", reportURL, strings.NewReader(reportPayload.Encode()))
		req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

		resp, err := c.httpClient.Do(req)
		if err != nil {
			lastErr = fmt.Errorf("gagal melakukan POST request laporan: %v", err)
			continue
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			body, _ := io.ReadAll(resp.Body)
			lastErr = fmt.Errorf("gagal mengambil laporan, status code: %d, body: %s", resp.StatusCode, string(body))
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		// Try to unmarshal to map[string]interface{} to check if valid JSON
		var test map[string]interface{}
		if err := json.Unmarshal(body, &test); err == nil && len(body) > 0 {
			return body, nil
		}
		lastErr = fmt.Errorf("response belum valid JSON, percobaan ke-%d", i+1)
		// Wait 2 seconds before next try
		time.Sleep(2 * time.Second)
	}
	return nil, lastErr
}
cat client/elasticsearch-auth.go
// client/elasticsearch-auth.go
package client

import (
	"fmt"
	"os"

	"github.com/elastic/go-elasticsearch/v8"
)

// ElasticsearchConfig menyimpan konfigurasi koneksi Elasticsearch
type ElasticsearchConfig struct {
	URL      string
	Username string
	Password string
	Index    string
}

func LoadElasticsearchConfig() ElasticsearchConfig {
	return ElasticsearchConfig{
		URL:      os.Getenv("ELASTICSEARCH_SERVER_URL"),
		Username: os.Getenv("ELASTICSEARCH_USER"),
		Password: os.Getenv("ELASTICSEARCH_PASS"),
		Index:    os.Getenv("ELASTICSEARCH_INDEX_NAME"),
	}
}

// ElasticsearchClient adalah client untuk koneksi Elasticsearch
type ElasticsearchClient struct {
	Client *elasticsearch.Client
	Config ElasticsearchConfig
}

func NewElasticsearchClient(cfg ElasticsearchConfig) (*ElasticsearchClient, error) {
	esCfg := elasticsearch.Config{
		Addresses: []string{cfg.URL},
		Username:  cfg.Username,
		Password:  cfg.Password,
	}
	es, err := elasticsearch.NewClient(esCfg)
	if err != nil {
		return nil, fmt.Errorf("gagal membuat client elasticsearch: %v", err)
	}
	return &ElasticsearchClient{Client: es, Config: cfg}, nil
}
cat client/ocs-auth-session.go
package client

import (
	"bytes"
	"crypto/tls"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

// OCSAuthConfig holds OCS web URL for authentication
type OCSAuthConfig struct {
	OCSURL string
}

func LoadOCSAuthConfig() OCSAuthConfig {
	// You can set OCS_URL in env, fallback to default
	ocsURL := os.Getenv("OCS_URL")
	if ocsURL == "" {
		ocsURL = "http://192.168.88.20/ocsreports/"
	}
	return OCSAuthConfig{OCSURL: ocsURL}
}

// AuthenticateOCSWeb tries to login to OCS web and returns username if valid, else error
func AuthenticateOCSWeb(ocsURL, username, password string) error {
	// 1. Get new PHPSESSID
	skipTLS := false
	if strings.HasPrefix(ocsURL, "https://") {
		skipTLS = true
	}
	tr := &http.Transport{}
	if skipTLS {
		tr.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	}
	client := &http.Client{Timeout: 10 * time.Second, Transport: tr}
	resp, err := client.Get(ocsURL)
	if err != nil {
		return fmt.Errorf("gagal akses OCS web: %w", err)
	}
	defer resp.Body.Close()
	var phpsessid string
	for _, c := range resp.Cookies() {
		if c.Name == "PHPSESSID" {
			phpsessid = c.Value
			break
		}
	}
	if phpsessid == "" {
		return errors.New("tidak dapat PHPSESSID dari OCS web")
	}

	// 2. POST login
	loginURL := ocsURL
	if !strings.HasSuffix(loginURL, "/index.php") {
		loginURL = strings.TrimRight(ocsURL, "/") + "/index.php"
	}
	data := url.Values{}
	data.Set("LOGIN", username)
	data.Set("PASSWD", password)
	data.Set("Valid_CNX", "Send")
	req, err := http.NewRequest("POST", loginURL, strings.NewReader(data.Encode()))
	if err != nil {
		return fmt.Errorf("gagal buat request login: %w", err)
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("Cookie", fmt.Sprintf("PHPSESSID=%s", phpsessid))

	resp2, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("gagal login ke OCS web: %w", err)
	}
	defer resp2.Body.Close()
	body, _ := ioutil.ReadAll(resp2.Body)
	if !bytes.Contains(body, []byte("My dashboard")) {
		return errors.New("Login to OCS Failed (Wrong username/password credentials)")
	}
	return nil
}
cat client/ocs-mysql-auth.go
// client/ocs-mysql-auth.go
package client

import (
	"fmt"
	"os"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

// OCSConfig menyimpan konfigurasi koneksi OCS MySQL
type OCSConfig struct {
	DBUrl  string
	DBPort string
	DBName string
	DBUser string
	DBPass string
}

// LoadOCSConfig membaca konfigurasi dari environment
func LoadOCSConfig() OCSConfig {
	return OCSConfig{
		DBUrl:  os.Getenv("OCS_DB_URL"),
		DBPort: os.Getenv("OCS_DB_PORT"),
		DBName: os.Getenv("OCS_DB_NAME"),
		DBUser: os.Getenv("OCS_DB_USER"),
		DBPass: os.Getenv("OCS_DB_PASS"),
	}
}

// OCSMySQLClient adalah client untuk koneksi OCS MySQL
type OCSMySQLClient struct {
	DB     *gorm.DB
	Config OCSConfig
}

// NewOCSMySQLClient membuat client baru dan mencoba koneksi ke OCS MySQL
func NewOCSMySQLClient(cfg OCSConfig) (*OCSMySQLClient, error) {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		cfg.DBUser, cfg.DBPass, cfg.DBUrl, cfg.DBPort, cfg.DBName)
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		return nil, err
	}
	return &OCSMySQLClient{DB: db, Config: cfg}, nil
}

// Ping untuk cek koneksi
func (c *OCSMySQLClient) Ping() error {
	db, err := c.DB.DB()
	if err != nil {
		return err
	}
	return db.Ping()
}
cat parser/ad-list-computers.go
// parser/ad-list-computers.go
package parser

import (
	"encoding/json"
	"fmt"
	"strings"
)

// RawReportColumn mendefinisikan struktur satu kolom dalam data mentah.
type RawReportColumn struct {
	Value    string `json:"VALUE"`
	AttribID int    `json:"ATTRIB_ID"`
}

// RawReportRow mendefinisikan struktur satu baris dalam data mentah.
type RawReportRow struct {
	Columns []RawReportColumn `json:"COLUMNS"`
}

// RawReportData adalah struktur tingkat atas dari JSON mentah.
type RawReportData struct {
	ResultRows []RawReportRow `json:"resultrows"`
}

// ComputerReportRow adalah struktur untuk hasil akhir yang kita inginkan.
type ComputerReportRow struct {
	ComputerName     string `json:"computer_name"`
	LastLogonTime    string `json:"last_logon_time"`
	ComputerStatus   string `json:"computer_status"`
	LastModifiedTime string `json:"ad_last_modified_time"`
}

// ParseComputerReport mengubah data mentah menjadi format sederhana.
func ParseComputerReport(rawData []byte) ([]ComputerReportRow, error) {
	// fmt.Println("\n[DEBUG] RAW JSON FROM AD:")
	// fmt.Println(string(rawData))
	var simplifiedList []ComputerReportRow

	idToKeyMap := map[int]string{
		3001: "computer_name",
		3019: "last_logon_time",
		3021: "computer_status",
		3012: "ad_last_modified_time",
	}

	// Try to unmarshal as the usual format first
	var parsedData RawReportData
	err := json.Unmarshal(rawData, &parsedData)
	if err == nil && len(parsedData.ResultRows) > 0 {
		for _, row := range parsedData.ResultRows {
			item := make(map[string]string)
			for _, col := range row.Columns {
				if key, ok := idToKeyMap[col.AttribID]; ok {
					item[key] = col.Value
				}
			}
			if name, ok := item["computer_name"]; ok {
				logon := item["last_logon_time"]
				status := item["computer_status"]
				modified := item["ad_last_modified_time"]
				simplifiedList = append(simplifiedList, ComputerReportRow{
					ComputerName:     name,
					LastLogonTime:    logon,
					ComputerStatus:   strings.ToLower(status),
					LastModifiedTime: modified,
				})
			}
		}
		return simplifiedList, nil
	}

	// If not, try to parse as array of objects keyed by ATTRIB_ID
	// The root may be an object with "resultrows" as []map[string]interface{}
	var generic map[string]interface{}
	if err := json.Unmarshal(rawData, &generic); err != nil {
		return nil, fmt.Errorf("gagal mem-parsing JSON mentah: %v", err)
	}
	rows, ok := generic["resultrows"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("format resultrows tidak dikenali")
	}
	for _, r := range rows {
		item := make(map[string]string)
		// r bisa berupa map[string]interface{} dengan key ATTRIB_ID
		if rowMap, ok := r.(map[string]interface{}); ok {
			for k, v := range rowMap {
				// k is always string, representing ATTRIB_ID
				var id int
				fmt.Sscanf(k, "%d", &id)
				if key, ok := idToKeyMap[id]; ok {
					switch val := v.(type) {
					case string:
						item[key] = val
					case float64:
						item[key] = fmt.Sprintf("%v", val)
					case int:
						item[key] = fmt.Sprintf("%v", val)
					}
				}
			}
			if name, ok := item["computer_name"]; ok {
				logon := item["last_logon_time"]
				status := item["computer_status"]
				modified := item["ad_last_modified_time"]
				simplifiedList = append(simplifiedList, ComputerReportRow{
					ComputerName:     name,
					LastLogonTime:    logon,
					ComputerStatus:   strings.ToLower(status),
					LastModifiedTime: modified,
				})
			}
		}
	}
	return simplifiedList, nil
}
cat parser/elasticsearch-combine-list-computers.go
package parser

import (
	"crypto/sha1"
	"encoding/hex"
	"strings"
	"time"
)

type FinalComputerRow struct {
	ComputerName                string `json:"computer_name"`
	ExistsInOCS                 bool   `json:"exists_in_ocs"`
	ExistsInAD                  bool   `json:"exists_in_ad"`
	OCSStatus                   string `json:"ocs_status"`
	ADStatus                    string `json:"ad_status"`
	OCSLastInventory            string `json:"ocs_last_inventory,omitempty"`
	OCSLastCome                 string `json:"ocs_last_come,omitempty"`
	ADLastLogonTime             string `json:"ad_last_logon_time,omitempty"`
	ADLastModifiedTime          string `json:"ad_last_modified_time,omitempty"`
	ADNotLoginMoreThan30d       *bool  `json:"ad_not_login_more_than_30d,omitempty"`
	ADNotLoginMoreThan45d       *bool  `json:"ad_not_login_more_than_45d,omitempty"`
	OCSLastInventoryMoreThan30d *bool  `json:"ocs_last_inventory_more_than_30d,omitempty"`
	OCSLastComeMoreThan30d      *bool  `json:"ocs_last_come_more_than_30d,omitempty"`
	OCSInactiveDurationDays     *int   `json:"ocs_inactive_duration_days,omitempty"`
	ADInactiveDurationDays      *int   `json:"ad_inactive_duration_days,omitempty"`
	SyncTime                    string `json:"@timestamp"`
}

// HashComputerName membuat hash dari nama komputer untuk deduplikasi.
func HashComputerName(name string) string {
	// Normalisasi: hapus semua spasi, ubah ke huruf kecil, hilangkan karakter non-alfanumerik
	norm := strings.ToLower(name)
	norm = strings.ReplaceAll(norm, " ", "")
	norm = strings.TrimSpace(norm)
	// Hilangkan karakter non-alfanumerik
	var filtered []rune
	for _, r := range norm {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
			filtered = append(filtered, r)
		}
	}
	norm = string(filtered)
	h := sha1.New()
	h.Write([]byte(norm))
	return hex.EncodeToString(h.Sum(nil))
}

// CombineOCSAndAD melakukan deduplikasi dan penggabungan data dari OCS dan AD.
func CombineOCSAndAD(ocsList []OCSComputerRow, adList []ComputerReportRow) []FinalComputerRow {
	cache := make(map[string]string) // hash -> computer_name
	result := make(map[string]*FinalComputerRow)

	// Helper untuk mem-parsing berbagai format waktu, mengembalikan time.Time dan status keberhasilan.
	parseTime := func(t string) (time.Time, bool) {
		if t == "" {
			return time.Time{}, false
		}
		// Daftar layout format waktu yang mungkin diterima
		layouts := []string{"2006-01-02 15:04:05", time.RFC3339, "2006-01-02T15:04:05Z"}
		for _, layout := range layouts {
			parsed, err := time.Parse(layout, t)
			if err == nil {
				return parsed, true
			}
		}
		return time.Time{}, false
	}

	// Helper baru untuk mengisi @timestamp (SyncTime) dengan zona waktu UTC-7.
	// Fungsi ini memilih timestamp prioritas (OCS > AD), memformatnya ke RFC3339,
	// dan memberikan nilai default jika keduanya tidak valid.
	getSyncTimestamp := func(ocsLastInventory, adLastLogon string) string {
		shift := -7 * time.Hour
		isZeroOrDash := func(s string) bool {
			return s == "0" || s == "-"
		}
		// Prioritas 1: Coba parse OCSLastInventory
		if !isZeroOrDash(ocsLastInventory) {
			if t, ok := parseTime(ocsLastInventory); ok {
				return t.Add(shift).UTC().Format(time.RFC3339)
			}
		}
		// Prioritas 2: Coba parse ADLastLogon
		if !isZeroOrDash(adLastLogon) {
			if t, ok := parseTime(adLastLogon); ok {
				return t.Add(shift).UTC().Format(time.RFC3339)
			}
		}
		// Jika field bernilai 0 atau -, gunakan waktu UTC+0 (tanpa shift)
		return time.Now().UTC().Format(time.RFC3339)
	}

	// Helper untuk pengecekan string "0" atau "-" dan waktu sekarang
	isZeroOrDash := func(s string) bool {
		return s == "0" || s == "-"
	}
	now := time.Now().Local()

	// Proses data dari OCS
	for _, ocs := range ocsList {
		key := HashComputerName(ocs.ComputerName)
		cache[key] = ocs.ComputerName
		// fmt.Printf("[DEBUG][OCS] ComputerName: '%s' | Hash: '%s'\n", ocs.ComputerName, key)

		// Logic untuk ocs_last_inventory_more_than_30d dan ocs_last_come_more_than_30d
		var ocsLastInventoryMoreThan30d *bool
		var ocsLastComeMoreThan30d *bool
		var ocsInactiveDurationDays *int
		if !isZeroOrDash(ocs.OCSLastInventory) {
			if t, ok := parseTime(ocs.OCSLastInventory); ok {
				b := now.Sub(t).Hours() > 24*30
				ocsLastInventoryMoreThan30d = &b
			}
		} else {
			b := true
			ocsLastInventoryMoreThan30d = &b
		}
		if !isZeroOrDash(ocs.OCSLastCome) {
			if t, ok := parseTime(ocs.OCSLastCome); ok {
				b := now.Sub(t).Hours() > 24*30
				ocsLastComeMoreThan30d = &b
				days := int(now.Sub(t).Hours() / 24)
				ocsInactiveDurationDays = &days
			}
		} else {
			b := true
			ocsLastComeMoreThan30d = &b
		}

		result[ocs.ComputerName] = &FinalComputerRow{
			ComputerName: ocs.ComputerName,
			ExistsInOCS:  true,
			ExistsInAD:   false,
			OCSStatus:    ocs.OCSStatus,
			ADStatus:     "",
			// Aturan 2: Biarkan format string original
			OCSLastInventory:            ocs.OCSLastInventory,
			OCSLastCome:                 ocs.OCSLastCome,
			ADLastLogonTime:             "",
			ADNotLoginMoreThan30d:       nil,
			ADNotLoginMoreThan45d:       nil,
			OCSLastInventoryMoreThan30d: ocsLastInventoryMoreThan30d,
			OCSLastComeMoreThan30d:      ocsLastComeMoreThan30d,
			OCSInactiveDurationDays:     ocsInactiveDurationDays,
			ADInactiveDurationDays:      nil,
			// Aturan 1 & 3: Buat @timestamp dalam format RFC3339 dari data OCS
			SyncTime: getSyncTimestamp(ocs.OCSLastInventory, ""),
		}
	}

	// Proses data dari AD dan gabungkan dengan data OCS yang ada
	// now dan isZeroOrDash sudah didefinisikan di atas
	for _, ad := range adList {
		key := HashComputerName(ad.ComputerName)
		// fmt.Printf("[DEBUG][AD] ComputerName: '%s' | Hash: '%s'\n", ad.ComputerName, key)

		// Hitung field login > 30/45 hari
		var moreThan30d *bool
		var moreThan45d *bool
		var adInactiveDurationDays *int
		if !isZeroOrDash(ad.LastLogonTime) {
			if t, ok := parseTime(ad.LastLogonTime); ok {
				b30 := now.Sub(t).Hours() > 24*30
				b45 := now.Sub(t).Hours() > 24*45
				moreThan30d = &b30
				moreThan45d = &b45
				days := int(now.Sub(t).Hours() / 24)
				adInactiveDurationDays = &days
			}
		} else {
			b := true
			moreThan30d = &b
			moreThan45d = &b
		}

		if cname, ok := cache[key]; ok {
			// Komputer sudah ada di OCS, update data AD
			row := result[cname]
			row.ExistsInAD = true
			row.ADStatus = ad.ComputerStatus
			// Aturan 2: Biarkan format string original
			row.ADLastLogonTime = ad.LastLogonTime
			row.ADLastModifiedTime = ad.LastModifiedTime
			row.ADNotLoginMoreThan30d = moreThan30d
			row.ADNotLoginMoreThan45d = moreThan45d
			row.ADInactiveDurationDays = adInactiveDurationDays
			// Aturan 1 & 3: Update @timestamp dengan mempertimbangkan data OCS dan AD
			row.SyncTime = getSyncTimestamp(row.OCSLastInventory, ad.LastLogonTime)
		} else {
			// Komputer hanya ada di AD
			result[ad.ComputerName] = &FinalComputerRow{
				ComputerName:     ad.ComputerName,
				ExistsInOCS:      false,
				ExistsInAD:       true,
				OCSStatus:        "",
				ADStatus:         ad.ComputerStatus,
				OCSLastInventory: "",
				OCSLastCome:      "",
				// Aturan 2: Biarkan format string original
				ADLastLogonTime:             ad.LastLogonTime,
				ADLastModifiedTime:          ad.LastModifiedTime,
				ADNotLoginMoreThan30d:       moreThan30d,
				ADNotLoginMoreThan45d:       moreThan45d,
				OCSLastInventoryMoreThan30d: nil,
				OCSLastComeMoreThan30d:      nil,
				OCSInactiveDurationDays:     nil,
				ADInactiveDurationDays:      adInactiveDurationDays,
				// Aturan 1 & 3: Buat @timestamp dalam format RFC3339 dari data AD
				SyncTime: getSyncTimestamp("", ad.LastLogonTime),
			}
		}
	}

	// Konversi map hasil ke slice untuk dikembalikan
	var finalList []FinalComputerRow
	for _, v := range result {
		finalList = append(finalList, *v)
	}
	return finalList
}
cat parser/ocs-list-computers.go
package parser

import (
	"time"

	"gorm.io/gorm"
)

type OCSComputerRow struct {
	ComputerName     string `json:"computer_name"`
	OCSStatus        string `json:"ocs_status"`
	OCSLastCome      string `json:"ocs_last_come"`
	OCSLastInventory string `json:"ocs_last_inventory"`
}

type Hardware struct {
	Name     string     `gorm:"column:NAME"`
	Archive  *int       `gorm:"column:ARCHIVE"`
	LastDate *time.Time `gorm:"column:LASTDATE"`
	LastCome *time.Time `gorm:"column:LASTCOME"`
}

func (Hardware) TableName() string {
	return "hardware"
}

func ListOCSComputers(db *gorm.DB, limit int) ([]OCSComputerRow, error) {
	var hardwares []Hardware
	q := db
	if limit > 0 {
		q = q.Limit(limit)
	}
	if err := q.Find(&hardwares).Error; err != nil {
		return nil, err
	}
	var result []OCSComputerRow
	for _, hw := range hardwares {
		status := "enabled"
		if hw.Archive != nil {
			status = "disabled"
		}
		lastCome := ""
		lastInventory := ""
		if hw.LastCome != nil {
			lastCome = hw.LastCome.Format("2006-01-02 15:04:05")
		}
		if hw.LastDate != nil {
			lastInventory = hw.LastDate.Format("2006-01-02 15:04:05")
		}
		result = append(result, OCSComputerRow{
			ComputerName:     hw.Name,
			OCSStatus:        status,
			OCSLastCome:      lastCome,
			OCSLastInventory: lastInventory,
		})
	}
	return result, nil
}
// main.go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"ocs-ad-inventorymanagement/api"
	"ocs-ad-inventorymanagement/client"
	"ocs-ad-inventorymanagement/parser"
	"ocs-ad-inventorymanagement/web"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

// loadConfig memuat konfigurasi dari variabel lingkungan.
func loadConfig() (client.Config, error) {
	// Memuat file .env, tidak akan error jika file tidak ada
	godotenv.Load()

	cfg := client.Config{}
	requiredVars := map[string]*string{
		"AD_BASE_URL":           &cfg.BaseURL,
		"AD_USERNAME":           &cfg.Username,
		"AD_ENCRYPTED_PASSWORD": &cfg.EncryptedPassword,
	}

	for key, valuePtr := range requiredVars {
		value := os.Getenv(key)
		if value == "" {
			return cfg, fmt.Errorf("variabel lingkungan wajib '%s' tidak diatur", key)
		}
		*valuePtr = value
	}
	return cfg, nil
}

func main() {
	// 1. Muat konfigurasi dari .env
	cfg, err := loadConfig()
	if err != nil {
		log.Fatalf("Gagal memuat konfigurasi: %v", err)
	}

	// 2. Buat client baru dengan konfigurasi yang sudah dimuat
	adClient, err := client.New(cfg)
	if err != nil {
		log.Fatalf("Gagal membuat client: %v", err)
	}

	// 3. Jalankan login menggunakan method dari client
	if err := adClient.Login(); err != nil {
		log.Fatalf("Proses login gagal: %v", err)
	}

	// Jalankan web API Gin untuk delete-computer secara async
	ocsCfg := client.LoadOCSConfig()
	ocsClient, err := client.NewOCSMySQLClient(ocsCfg)
	if err != nil {
		log.Fatalf("[ERROR] OCS - Koneksi gagal: %v", err)
	}
	if err := ocsClient.Ping(); err != nil {
		log.Fatalf("[ERROR] OCS - Autentikasi gagal: %v", err)
	}

	gin.SetMode(gin.ReleaseMode)
	r := gin.New()

	basePath := os.Getenv("BASE_PATH_URL")
	if basePath == "" {
		basePath = "/ocsextra"
	}
	// Pastikan basePath diawali dengan /
	if !strings.HasPrefix(basePath, "/") {
		basePath = "/" + basePath
	}
	// Pastikan basePath tidak diakhiri / (kecuali root)
	if len(basePath) > 1 && strings.HasSuffix(basePath, "/") {
		basePath = strings.TrimRight(basePath, "/")
	}

	apiGroup := r.Group(basePath + "/api")
	apiGroup.POST("/auth-token", api.AuthTokenHandler)
	apiGroup.POST("/delete-computer", api.DeleteComputerHandler(ocsClient.DB))

	// Frontend GET
	r.GET(basePath+"/delete-computer", func(c *gin.Context) {
		c.Header("Content-Type", "text/html; charset=utf-8")
		c.String(200, web.FrontendHTML)
	})

	// Ambil port dari env, default 8080
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	addr := ":" + port
	go func() {
		if err := r.Run(addr); err != nil {
			log.Fatalf("[ERROR] Gagal menjalankan web API: %v", err)
		}
	}()

	// Refresher: perbarui generationId setiap 12 jam sekali
	go func() {
		reportId := "210"
		params := `{"selectedDomains":["satnusa.com"],"domainVsOUList":{"DC=satnusa,DC=com":[]},"domainVsExcludeOUList":{"DC=satnusa,DC=com":[]},"domainVsExcludeChildOU":{"DC=satnusa,DC=com":false}}`
		for {
			if !adClient.IsSessionValid() {
				log.Println("[INFO] ADManager Plus - Session expired. Renewing session for GenerationID refresh...")
				if err := adClient.Login(); err != nil {
					log.Printf("[ERROR] ADManager Plus - Login failed during GenerationID refresh: %v", err)
					time.Sleep(60 * time.Second)
					continue
				}
			}
			if err := adClient.RefreshGenerationID(reportId, params); err != nil {
				log.Printf("[ERROR] Gagal refresh generationId: %v", err)
				time.Sleep(300 * time.Second)
				continue
			}
			time.Sleep(43200 * time.Second)
		}
	}()

	// Scheduler: jalankan sinkronisasi setiap 60 detik
	for {
		// Print session validity before login
		if adClient.IsSessionValid() {
			log.Println("[INFO] ADManager Plus - Session is still valid.")
		} else {
			log.Println("[INFO] ADManager Plus - Session expired. Renewing session...")
			if err := adClient.Login(); err != nil {
				log.Fatalf("Proses login AD Manager Plus gagal: %v", err)
			}
			if adClient.IsSessionValid() {
				log.Println("[INFO] ADManager Plus - Session renewed and valid.")
			} else {
				log.Println("[ERROR] ADManager Plus - Session renewal failed.")
			}
		}
		rawData, err := adClient.FetchComputerReport()
		if err != nil {
			log.Fatalf("Proses pengambilan laporan AD gagal: %v", err)
		}

		// Parse data AD terbaru
		cleanData, err := parser.ParseComputerReport(rawData)
		if err != nil {
			log.Fatalf("Proses transformasi data AD gagal: %v", err)
		}
		log.Printf("[SUCCESS] AD Manager Plus - Data successfully parsed, Total: %d", len(cleanData))

		// List komputer OCS
		ocsComputers, err := parser.ListOCSComputers(ocsClient.DB, 0)
		if err != nil {
			log.Printf("[ERROR] Gagal mengambil data komputer OCS: %v", err)
			continue
		}
		log.Printf("[SUCCESS] OCS - Data successfully parsed, Total: %d", len(ocsComputers))

		// Gabungkan data OCS dan AD
		finalList := parser.CombineOCSAndAD(ocsComputers, cleanData)
		log.Printf("[SUCCESS] OCS x AD - Combined Data, Total: %d", len(finalList))

		// Simpan ke Elasticsearch
		esCfg := client.LoadElasticsearchConfig()
		esClient, err := client.NewElasticsearchClient(esCfg)
		if err != nil {
			log.Printf("[ERROR] Gagal membuat client Elasticsearch: %v", err)
			continue
		}

		// --- Sinkronisasi dua arah: hapus data yang sudah tidak ada di OCS/AD ---
		cacheOCS := make(map[string]struct{})
		cacheAD := make(map[string]struct{})
		hashName := func(name string) string {
			return parser.HashComputerName(name)
		}
		for _, ocs := range ocsComputers {
			cacheOCS[hashName(ocs.ComputerName)] = struct{}{}
		}
		for _, ad := range cleanData {
			cacheAD[hashName(ad.ComputerName)] = struct{}{}
		}

		var esIDs []string
		from := 0
		size := 10000
		for {
			query := `{"query":{"match_all":{}},"_source":false,"from":` + fmt.Sprintf("%d", from) + `,"size":` + fmt.Sprintf("%d", size) + `}`
			res, err := esClient.Client.Search(
				esClient.Client.Search.WithIndex(esCfg.Index),
				esClient.Client.Search.WithBody(strings.NewReader(query)),
			)
			if err != nil {
				log.Printf("[ERROR] Gagal mengambil document ID dari Elasticsearch: %v", err)
				break
			}
			defer res.Body.Close()
			var resp struct {
				Hits struct {
					Hits []struct {
						ID string `json:"_id"`
					} `json:"hits"`
				} `json:"hits"`
			}
			if err := json.NewDecoder(res.Body).Decode(&resp); err != nil {
				log.Printf("[ERROR] Gagal decode response Elasticsearch: %v", err)
				break
			}
			if len(resp.Hits.Hits) == 0 {
				break
			}
			for _, hit := range resp.Hits.Hits {
				esIDs = append(esIDs, hit.ID)
			}
			if len(resp.Hits.Hits) < size {
				break
			}
			from += size
		}

		deleted := 0
		for _, id := range esIDs {
			h := hashName(id)
			_, existsOCS := cacheOCS[h]
			_, existsAD := cacheAD[h]
			if !existsOCS && !existsAD {
				res, err := esClient.Client.Delete(esCfg.Index, id)
				if err != nil {
					log.Printf("[ERROR] Gagal hapus document %s di Elasticsearch: %v", id, err)
					continue
				}
				if res.IsError() {
					log.Printf("[ERROR] Elasticsearch response error saat hapus %s: %s", id, res.String())
				} else {
					deleted++
				}
				res.Body.Close()
			}
		}
		log.Printf("[INFO] OCS x AD - Remove Deleted Data, Total: %d", deleted)

		// --- Index/update data yang masih ada, gunakan batch dan paralel (goroutine) ---
		batchSize := 500
		maxParallel := 4
		type indexResult struct {
			success int
			failed  int
		}
		indexBatch := func(batch []parser.FinalComputerRow, ch chan<- indexResult) {
			success, failed := 0, 0
			for _, row := range batch {
				docID := row.ComputerName
				body, _ := json.Marshal(row)
				res, err := esClient.Client.Index(esCfg.Index, strings.NewReader(string(body)), esClient.Client.Index.WithDocumentID(docID))
				if err != nil {
					log.Printf("[ERROR] Indexing gagal untuk %s: %v", docID, err)
					failed++
					continue
				}
				if res.IsError() {
					log.Printf("[ERROR] Elasticsearch response error untuk %s: %s", docID, res.String())
					failed++
				} else {
					success++
				}
				res.Body.Close()
			}
			ch <- indexResult{success, failed}
		}

		var batches [][]parser.FinalComputerRow
		for i := 0; i < len(finalList); i += batchSize {
			end := i + batchSize
			if end > len(finalList) {
				end = len(finalList)
			}
			batches = append(batches, finalList[i:end])
		}

		ch := make(chan indexResult, len(batches))
		sem := make(chan struct{}, maxParallel)

		for _, batch := range batches {
			sem <- struct{}{} // acquire
			go func(b []parser.FinalComputerRow) {
				defer func() { <-sem }() // release
				indexBatch(b, ch)
			}(batch)
		}

		success, failed := 0, 0
		for i := 0; i < len(batches); i++ {
			res := <-ch
			success += res.success
			failed += res.failed
		}
		log.Printf("[INFO] Indexing Finished (Batch Parallel). Success: %d, Failed: %d", success, failed)

		time.Sleep(60 * time.Second)
	}
}
